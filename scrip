

Коллеги, подготовил скрипт, файл во вложении

 

Впервые писал подобный скрипт для ЕСС, поэтому столкнулся с некоторыми проблемами и особенностями:

1.       Запрос предполагает параметры. Не во всех СУБД параметры используются одинаково, а в HUE, например, я вообще не могу их использовать. Поэтому сделал вариант через CTE, чтобы не вписывать эти данные хардкодом в текст запроса, а зафиксировать их в начале

a.       ИНН задается в CTE inn_list. Можно вписать больше одного ИНН, запрос будет работать

b.       Дата начала и дата окончания построения отчета задаются в CTE date_list, в атрибутах date_start и date_end. Здесь даты нужны однозначные

c.       Завел еще один CTE client_flag для ввода варианта, ИНН кого конкретно ищется (проставить 1 у атрибута is_applicant или is_benefitiary), но не смог это никак применить, так как HUE в одном месте будет жаловаться на множественность вложенных запросов в одной из CTE. Поэтому этот момент нужно менять в коде. В CTE agr_sk_list_pre в предложении WHERE нужно оставить одно из условий:

                                                               i.      Если нужны сделки, где в начале задается ИНН аппликанта/плательщика: agr_proc.letter_cred_org_buyer_subj_sk in (select subj_sk from subj_list)

                                                             ii.      Если нужны сделки, где в начале задается ИНН бенефициара/получателя: agr_proc.docum_tran_seller_subj_sk in (select subj_sk from subj_list)

Возможно, придумаю, как это обойти и использовать первоначальный вариант с флагами

2.       Весь запрос обрабатывает сделки, которые ранее велись или сейчас продолжают вестись в старой реплике DFLike. У нас сейчас наблюдаются некоторые проблемы в IDL: международные аккредитивы, которые мигрировали в целевую реплику, по-прежнему отбираются из старой реплики. Мы исправим эту проблему в релизе 16.11.25. Этот вариант запроса работает со схемой tradefin_ndl_uvdo

3.       Запрос, обрабатывающий сделки, которые ведутся в целевом источнике GStream, пока не отлажен. В конечном виде этот запрос будет расширен логикой обработки данных из GStream. Постараюсь отладить второй кусок запроса в течение нескольких дней. И после релиза 16.11.25 данные в IDL будут корректны склеены по всем ПА и НПА данными из обоих источников

4.       Запрос написан по скрипту Андрея Николаенко и в нем набор атрибутов несколько отличается от тех форм, которые были присланы в качестве примера

a.       Вопрос 1: нужно ли добавить в запрос атрибуты, которые отсутствуют в оригинальном скрипте, но присутствуют в формах?

b.       Вопрос 2: нужно ли убрать из запроса атрибуты, которые присутствуют в оригинальном скрипте, но отсутствуют в формах?

5.       Самая большая проблема построения таких форм на ЕСС в самой архитектуре хранилища, но мне удалось оптимизировать скрипт, и он отрабатывается за минуты даже обращаясь напрямую (или через подписки) к HDFS, то есть не обязательно реплицировать данные куда-то к себе в БД

6.       Сходимость данных проверил на присланных примерах. Во вложении файл «Томинский_ГОК» по соответствующему плательщику из присланного примера. Есть некоторые расхождения:

a.       В примере 26 сделок, запрос выдал 36 (все те же 26 оригинальных, но 10 каких-то дополнительных). Однозначной причины этого не нашел. В примере нет сделок, которые ведутся в целевой фабрике (а в L2P реплику они прилетают обратным потоком), но таких сделок всего 4 (у них отрицательный «id аккредитива в dflike» на листе «Данные_скрипта»)

b.       Некоторые сделки в примере отчета имеют даты закрытия, но в нашем источнике эти сделки еще открыты

c.       Атрибут «Дата истечения» сильно расходится. Быстро определить причину не смог, нужны доработки

d.       Некоторые суммы (например, «Остаток в валюте досье») отличаются от данных отчета. Предполагаю, из-за разных дат построения формы в примере и в этой выгрузке. В примере написано, что отчет сформирован «За период 30.06.25 по 30.06.25». Тут, наверное, у меня не хватает понимания логики, так как в запросе агрегируются суммы разных операций (платежи, возмещения и т.д.) в заданный период, и если отчет строится за 1 день, то много платежей просто не попадет. Данные в примере действительно построены за 1 день?

 ---- CTE для ввода параметров отчета
-- ввод интересующего ИНН клиента
with inn_list as (
select '7403005526' as inn
)

-- ввод периода построения отчета
, date_list as (
select '2020-01-01' as date_start, '2025-11-01' as date_end 
)

-- ввод параметра типа клиента (аппликант или бенефициар). is_applicant и is_benefitiary взаимоисключающие параметры запроса
, client_flag as (
select 1 as is_applicant, 0 as is_benefitiary
)

---- CTE для отбора нужных клиентов/сделок/операций
, subj_list as (
select distinct 
  subj_h.subj_dp_code
  , subj_h.subj_sk
from usl_tradefin_ndl_uvdo_snp.subj_h
where inn_num in (select inn from inn_list)
union
select distinct 
  subj_h.subj_dp_code
  , subj_h.subj_sk 
from usl_subj_org_idl_snp.subj_h
where inn_num in (select inn from inn_list)
)

, agr_sk_list_pre as (
select distinct 
  agr_proc.agr_sk
from usl_tradefin_ndl_uvdo_snp.agr_proc
inner join usl_tradefin_ndl_uvdo_snp.agr
  on agr_proc.agr_sk = agr.agr_sk
inner join usl_tradefin_ndl_uvdo_snp.letter_cred_type lct
  on agr.letter_cred_type_sk = lct.letter_cred_type_sk
where 
  (lct.sid in ('1', '2', '10') or agr.type_code in ('ind', 'ind_draft'))
  and (
    agr_proc.letter_cred_org_buyer_subj_sk in (select subj_sk from subj_list)
--    or agr_proc.docum_tran_seller_subj_sk in (select subj_sk from subj_list)
  )
)

, plan_payment as (
select distinct
  plan.plan_payment_agr_sk as agr_sk
from agr_sk_list_pre
inner join usl_tradefin_ndl_uvdo_snp.letter_cred_org_plan_payment plan
  on agr_sk_list_pre.agr_sk = plan.plan_payment_agr_sk
cross join date_list
where 
  split(plan.sid, '\\|')[0] in ('VOZMPA4410', 'VOZMPA')
  and coalesce(plan.letter_cred_org_plan_payment_amt, 0) > 0
  and plan.letter_cred_org_plan_payment_dt >= date_list.date_start
)

, agr_sk_list_fin as (
select distinct
  agr.agr_sk
  , agr.sid
  , agr.num
  , agr_fin.docum_tran_amt
  , agr_fin.docum_tran_crncy_sk
  , agr.letter_cred_coverage_flag
  , agr.letter_cred_source_coverage_type_sk
  , agr.open_dt
  , agr.close_dt
from agr_sk_list_pre pre
inner join usl_tradefin_ndl_uvdo_snp.agr
  on pre.agr_sk = agr.agr_sk
inner join usl_tradefin_ndl_uvdo_snp.agr_fin
  on agr.agr_sk = agr_fin.agr_sk
left join plan_payment
  on agr.agr_sk = plan_payment.agr_sk
cross join date_list
where
  agr.open_dt < date_list.date_end
  and (
    agr.close_dt is null
    or plan_payment.agr_sk is not null
    or (agr.close_dt > date_list.date_start and agr.close_dt < date_list.date_end)
  )
  and agr_fin.end_dt = '9999-12-31'
)

, operations_list as (
select distinct
  optn.agr_sk
  , optn.optn_dttm
  , optn.type_code
  , optn.sum_opt_amt
  , optn.crncy_dp_code
  , optn.crncy_sk
  , toptn.group_code
from agr_sk_list_fin
inner join usl_tradefin_ndl_uvdo_snp.optn
  on agr_sk_list_fin.agr_sk = optn.agr_sk
cross join date_list
left join usl_tradefin_ndl_uvdo_snp.toptn
  on optn.toptn_sk = toptn.toptn_sk
where 
  optn.optn_dttm >= date_list.date_start
  and optn.optn_dttm <= date_list.date_end
)

---- Основные расчетные CTE
, A AS
(
select 
  agr.agr_sk
  , agr.num
  , sum(coalesce(optn.sum_opt_amt, 0)) as nSumPercent
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
where 1 = 1
  and optn.group_code in ('PayProc')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, B AS
(
select 
  agr.agr_sk
  , agr.num
  , sum(coalesce(optn.sum_opt_amt, 0)) as nSumDeferSB
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
where 1 = 1
  and optn.group_code in ('DefPayFee', 'DefPayFeeGS', 'PayCredit', 'PayCredit5')
  and optn.type_code = 'Commission'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, D AS      -- Отвлечение в валюте сделки
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(coalesce(optn.sum_opt_amt, 0)), 2) as nSumBankPay
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
where 1 = 1
  and optn.group_code in ('BankPay')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, Drub AS     -- Отвлечение в рублях
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(
      case
        when crncy.digital_code = '643' then optn.sum_opt_amt
        when crncy.digital_code != '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
        end), 2) as nSumBankPay
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
left join usl_rdm_idl_spark_snp.crncy
  on optn.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
where 1 = 1
  and optn.group_code in ('BankPay')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, E AS        -- Платежи в валюте сделки
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(
      case
        when agr.docum_tran_crncy_sk = optn.crncy_sk then optn.sum_opt_amt
        when crncy.digital_code != '643' and crncy_agr.digital_code = '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
        when crncy.digital_code = '643' and crncy_agr.digital_code != '643' then (optn.sum_opt_amt * r_dt_agr.qty_rub_cnt) / r_dt_agr.rub_rate_amt
        when crncy.digital_code != '643' and crncy_agr.digital_code != '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt * r_dt_agr.qty_rub_cnt) / (r_dt.qty_rub_cnt * r_dt_agr.rub_rate_amt) 
        end), 2) as nSumPay
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
  
left join usl_rdm_idl_spark_snp.crncy
  on optn.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
  
left join usl_rdm_idl_spark_snp.crncy crncy_agr
  on agr.docum_tran_crncy_sk = crncy_agr.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r_agr
  on crncy_agr.crncy_sk = r_agr.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt_agr
  on r_agr.cbr_exchange_rate_sk = r_dt_agr.cbr_exchange_rate_sk
  and r_dt_agr.point_dt = current_date
where 1 = 1
  and optn.group_code in ('PrePay', 'Prepay', 'Pay', 'Expire'/*, 'ReturnCover'*/)
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, EC AS       -- Платежи в валюте сделки
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(
      case
        when (agr.docum_tran_crncy_sk = optn.crncy_sk) or (crncy.digital_code = '643' and crncy_agr.digital_code = '643') then optn.sum_opt_amt
        when crncy.digital_code != '643' and crncy_agr.digital_code = '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
        when crncy.digital_code = '643' and crncy_agr.digital_code != '643' then (optn.sum_opt_amt * r_dt_agr.qty_rub_cnt) / r_dt_agr.rub_rate_amt
        when crncy.digital_code != '643' and crncy_agr.digital_code != '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt * r_dt_agr.qty_rub_cnt) / (r_dt.qty_rub_cnt * r_dt_agr.rub_rate_amt) 
        end), 2) as nSumPay
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
  
left join usl_rdm_idl_spark_snp.crncy
  on optn.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
  
left join usl_rdm_idl_spark_snp.crncy crncy_agr
  on agr.docum_tran_crncy_sk = crncy_agr.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r_agr
  on crncy_agr.crncy_sk = r_agr.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt_agr
  on r_agr.cbr_exchange_rate_sk = r_dt_agr.cbr_exchange_rate_sk
  and r_dt_agr.point_dt = current_date
where 1 = 1
  and optn.group_code in ('PrePay', 'Prepay', 'Pay', 'ReturnCover')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, ERub AS     -- Платежи в рублях
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(
      case
        when crncy.digital_code = '643' then optn.sum_opt_amt
        when crncy.digital_code != '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
        end), 2) as nSumPay
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
left join usl_rdm_idl_spark_snp.crncy
  on optn.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
where 1 = 1
  and optn.group_code in ('PrePay', 'Prepay', 'Pay', 'Expire', 'ReturnCover')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, ECRub AS    -- Платежи в валюте сделки
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(
      case
        when crncy.digital_code = '643' then optn.sum_opt_amt
        when crncy.digital_code != '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
        end), 2) as nSumPay
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
left join usl_rdm_idl_spark_snp.crncy
  on optn.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
where 1 = 1
  and optn.group_code in ('PrePay', 'Prepay', 'Pay', 'ReturnCover')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, F AS        -- Возмещения в валюте досье
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(optn.sum_opt_amt), 2) as nSumBankReturn
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
where 1 = 1
  and optn.group_code in ('BankReturn')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, FRub AS     -- Возмещения в рублях
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(
      case
        when crncy.digital_code = '643' then optn.sum_opt_amt
        when crncy.digital_code != '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
        end), 2) as nSumBankReturn
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
left join usl_rdm_idl_spark_snp.crncy
  on optn.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
where 1 = 1
  and optn.group_code in ('BankReturn')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, DF AS       -- Отвлечение в валюте сделки
(
select 
  C.agr_sk
  , case
      when D.crncy_sk = C.docum_tran_crncy_sk then (D.nSumBankPay  - F.nSumBankReturn) 
      when crncy.digital_code != '643' and crncy_agr.digital_code = '643' then ((D.nSumBankPay  - F.nSumBankReturn) * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
      when crncy.digital_code = '643' and crncy_agr.digital_code != '643' then ((D.nSumBankPay  - F.nSumBankReturn) * r_dt_agr.qty_rub_cnt) / r_dt_agr.rub_rate_amt
      when crncy.digital_code != '643' and crncy_agr.digital_code != '643' then ((D.nSumBankPay  - F.nSumBankReturn) * r_dt.rub_rate_amt * r_dt_agr.qty_rub_cnt) / (r_dt.qty_rub_cnt * r_dt_agr.rub_rate_amt) 
      end as nSum
from agr_sk_list_fin C
inner join D
  on C.agr_sk = D.agr_sk
left join F
  on C.agr_sk = F.agr_sk

left join usl_rdm_idl_spark_snp.crncy
  on D.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
  
left join usl_rdm_idl_spark_snp.crncy crncy_agr
  on C.docum_tran_crncy_sk = crncy_agr.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r_agr
  on crncy_agr.crncy_sk = r_agr.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt_agr
  on r_agr.cbr_exchange_rate_sk = r_dt_agr.cbr_exchange_rate_sk
  and r_dt_agr.point_dt = current_date
)

, DFRub AS    -- Отвлечение в валюте сделки
(
select 
  C.agr_sk
  , case
      when crncy.digital_code = '643' then (D.nSumBankPay  - F.nSumBankReturn)
      when crncy.digital_code != '643' then ((D.nSumBankPay  - F.nSumBankReturn) * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
      end as nSum
from agr_sk_list_fin C
inner join D
  on C.agr_sk = D.agr_sk
left join F
  on C.agr_sk = F.agr_sk

left join usl_rdm_idl_spark_snp.crncy
  on D.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
)

, G AS        -- Покрытие в валюте досье
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(
      case
        when (agr.docum_tran_crncy_sk = optn.crncy_sk) or (crncy.digital_code = '643' and crncy_agr.digital_code = '643') then optn.sum_opt_amt
        when crncy.digital_code != '643' and crncy_agr.digital_code = '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
        when crncy.digital_code = '643' and crncy_agr.digital_code != '643' then (optn.sum_opt_amt * r_dt_agr.qty_rub_cnt) / r_dt_agr.rub_rate_amt
        when crncy.digital_code != '643' and crncy_agr.digital_code != '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt * r_dt_agr.qty_rub_cnt) / (r_dt.qty_rub_cnt * r_dt_agr.rub_rate_amt) 
        end), 2) as nSumCover
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
  
left join usl_rdm_idl_spark_snp.crncy
  on optn.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
  
left join usl_rdm_idl_spark_snp.crncy crncy_agr
  on agr.docum_tran_crncy_sk = crncy_agr.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r_agr
  on crncy_agr.crncy_sk = r_agr.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt_agr
  on r_agr.cbr_exchange_rate_sk = r_dt_agr.cbr_exchange_rate_sk
  and r_dt_agr.point_dt = current_date
where 1 = 1
  and optn.group_code in ('Cover')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, GRub AS     -- Покрытие в рублях
(
select 
  agr.agr_sk
  , agr.num
  , round(sum(
      case
        when crncy.digital_code = '643' then optn.sum_opt_amt
        when crncy.digital_code != '643' then (optn.sum_opt_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt
        end), 2) as nSumCover
  , optn.crncy_sk
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
left join usl_rdm_idl_spark_snp.crncy
  on optn.crncy_sk = crncy.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
where 1 = 1
  and optn.group_code in ('Cover')
  and optn.type_code = 'Operation'
group by agr.agr_sk, optn.crncy_sk, agr.num
)

, BRPlan AS   -- Для сделок отбираем максимальную дату операции планового возмещения \ плановой даты погашения досрочного платежа
(
select 
  agr.agr_sk
  , agr.num
  , MAX(optn.optn_dttm) AS dDate
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
where 1 = 1
  and optn.group_code in ('Request', 'ReturnSchedule','DeferPayReturn')
group by agr.agr_sk, agr.num
)

, BRFact AS   -- Для сделок отбираем максимальную дату операции планового возмещения
(
select 
  agr.agr_sk
  , agr.num
  , MAX(optn.optn_dttm) AS dDate
from agr_sk_list_fin agr
inner join operations_list optn
  on agr.agr_sk = optn.agr_sk
where 1 = 1
  and optn.group_code in ('BankReturn')
group by agr.agr_sk, agr.num
)

---- MAIN SELECT
select distinct
  C.sid                             as `ID аккредитива в dflike`
  , C.num                           as `Номер аккредитива`
  , cast(C.docum_tran_amt as float) as `Сумма аккредитива (на дату открытия)`
  , crncy.iso_code                  as `Валюта аккредитива`
  , C.open_dt                       as `Дата открытия`
  , C.close_dt                      as `Дата закрытия`
  , agr_cond.mat_dt                 as `Дата истечения (дата погашения обязательств по аккредитиву)`
  , C.letter_cred_coverage_flag     as `Флаг покрытого аккрдитива`
  , lcs.letter_cred_source_coverage_type_name   as `Тип источника покрытия`
  , cast(round(
      case
        when C.letter_cred_coverage_flag = false then round(agr_fin.docum_tran_amt, 2)
        when C.letter_cred_coverage_flag = true then round(coalesce(G.nSumCover, 0), 2)
      end 
    - 
      case
        when C.letter_cred_coverage_flag = false then round(coalesce(E.nSumPay, 0), 2)
        when C.letter_cred_coverage_flag = true then round(coalesce(EC.nSumPay, 0), 2)
      end
    + 
      coalesce(DF.nSum, 0) , 2) as float)     as `Остаток в валюте аккредитива (на дату окончания периода)`
  , cast(agr_fin.docum_tran_amt as float)     as `Сумма сделки НПА на дату отчета`
  , cast(coalesce(G.nSumCover, 0) as float)   as `Сумма сделки ПА на дату отчета`
  , cast(coalesce(DF.nSum, 0) as float)       as `Невозмещенное отвлечение в валюте сделки`
  , cast(round(
      case
        when C.letter_cred_coverage_flag = false then
          case
            when crncy_2.digital_code = '643' then round(agr_fin.docum_tran_amt, 2)
						else ((agr_fin.docum_tran_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt) 
            end
        when C.letter_cred_coverage_flag = true then coalesce(GRub.nSumCover, 0)
      end  
    -
      case
        when C.letter_cred_coverage_flag = false then coalesce(ERub.nSumPay, 0)
        when C.letter_cred_coverage_flag = true then coalesce(ECRub.nSumPay, 0)
      end 
    +
      coalesce(DFRub.nSum, 0), 2) as float)   as `Остаток (на дату окончания периода) (руб.)`
  , cast(agr_fin.docum_tran_amt as float)     as `Сумма сделки НПА на дату отчета если валюта RUR`
  , cast(round(((agr_fin.docum_tran_amt * r_dt.rub_rate_amt) / r_dt.qty_rub_cnt), 2) as float)    as `Сумма сделки НПА на дату отчета если валюта не RUR`
  , r_dt.rub_rate_amt                         as `Курс nr`
  , r_dt.qty_rub_cnt                          as `Курс nv`
  , cast(coalesce(DFRub.nSum, 0) as float)    as `Невозмещенное отвлечение в рублях`
  , cast(coalesce(B.nSumDeferSB, 0) as float) as `Плата за отсрочку Банка, списанная за отчетный период`
  , crncy_b.iso_code                          as `Валюта платы`
  , cast(coalesce(A.nSumPercent, 0) as float) as `Выплаченные проценты на остаток покрытия`
  , crncy_a.iso_code                          as `Валюта процентов`
  , case when optn_m.agr_sk is null then false else true end  as `Признак миграции`
from agr_sk_list_fin C
left join A 
  on C.agr_sk = A.agr_sk
left join B 
  on C.agr_sk = B.agr_sk
left join D 
  on C.agr_sk = D.agr_sk
left join F 
  on C.agr_sk = F.agr_sk
left join DF 
  on C.agr_sk = DF.agr_sk
left join DFRub 
  on C.agr_sk = DFRub.agr_sk
left join E 
  on C.agr_sk = E.agr_sk
left join ERub 
  on C.agr_sk = ERub.agr_sk
left join EC 
  on C.agr_sk = EC.agr_sk
left join ECRub 
  on C.agr_sk = ECRub.agr_sk
left join G 
  on C.agr_sk = G.agr_sk
left join GRub 
  on C.agr_sk = GRub.agr_sk
left join BRPlan 
  on C.agr_sk = BRPlan.agr_sk
left join BRFact 
  on C.agr_sk = BRFact.agr_sk
left join operations_list optn 
  on C.agr_sk = optn.agr_sk
left join operations_list optn_m 
  on C.agr_sk = optn_m.agr_sk and optn_m.group_code in ('Migration')
left join usl_tradefin_ndl_uvdo_snp.letter_cred_source_coverage_type lcs 
  on C.letter_cred_source_coverage_type_sk = lcs.letter_cred_source_coverage_type_sk
left join usl_rdm_idl_spark_snp.crncy
  on C.docum_tran_crncy_sk = crncy.crncy_sk
left join usl_tradefin_ndl_uvdo_snp.agr_cond
  on C.agr_sk = agr_cond.agr_sk and agr_cond.end_dt = '9999-12-31'
left join usl_tradefin_ndl_uvdo_snp.agr_fin
  on C.agr_sk = agr_fin.agr_sk and current_date >= agr_fin.start_dt and current_date < agr_fin.end_dt
left join usl_rdm_idl_spark_snp.crncy crncy_2
  on agr_fin.docum_tran_crncy_sk = crncy_2.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate r
  on crncy.crncy_sk = r.crncy_sk
left join usl_gmrates_idl_snp.cbr_exchange_rate_dt r_dt
  on r.cbr_exchange_rate_sk = r_dt.cbr_exchange_rate_sk
  and r_dt.point_dt = current_date
left join usl_rdm_idl_spark_snp.crncy crncy_b
  on B.crncy_sk = crncy_b.crncy_sk
left join usl_rdm_idl_spark_snp.crncy crncy_a
  on A.crncy_sk = crncy_a.crncy_sk






createtab_stmt

CREATE EXTERNAL TABLE `subj_h`(

`ctl_loading` bigint,

`ctl_validfrom` timestamp,

`end_dt` date,

`inn_num` string,

`start_dt` date,

`subj_dp_code` string,

`subj_sk` bigint,

`tax_resident_rf_flag` boolean,

`type_code` string)

PARTITIONED BY (

`p1month` string)

ROW FORMAT SERDE

'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'

STORED AS INPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'

OUTPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat'

LOCATION

'hdfs://hdfsgw/arnsdpfess2__USL_TRADEFIN_IDL_SNP_TAV-USL_TRADEFIN_IDL_SNP-SUBJ_H/data/usl/tradefin_idl/snp/subj_h'

TBLPROPERTIES (

'bucketing_version'='2',

'spark.sql.create.version'='2.2 or prior',

'spark.sql.sources.schema.numPartCols'='1',

'spark.sql.sources.schema.numParts'='1',

'spark.sql.sources.schema.part.0'='{"type":"struct","fields":[{"name":"ctl_loading","type":"long","nullable":true,"metadata":{}},{"name":"ctl_validfrom","type":"timestamp","nullable":true,"metadata":{}},{"name":"end_dt","type":"date","nullable":true,"metadata":{}},{"name":"inn_num","type":"string","nullable":true,"metadata":{}},{"name":"start_dt","type":"date","nullable":true,"metadata":{}},{"name":"subj_dp_code","type":"string","nullable":true,"metadata":{}},{"name":"subj_sk","type":"long","nullable":true,"metadata":{}},{"name":"tax_resident_rf_flag","type":"boolean","nullable":true,"metadata":{}},{"name":"type_code","type":"string","nullable":true,"metadata":{}},{"name":"p1month","type":"string","nullable":true,"metadata":{}}]}',

'spark.sql.sources.schema.partCol.0'='p1month',

'transient_lastDdlTime'='1765607821')

 

createtab_stmt

CREATE EXTERNAL TABLE `prx_usl_tradefin_ndl_uvdo_xs_snp_usl_tradefin_ndl_uvdo_xs_snp.subj_h`(

`ctl_loading` bigint,

`ctl_validfrom` timestamp,

`end_dt` date,

`inn_num` string,

`start_dt` date,

`subj_dp_code` string,

`subj_sk` bigint,

`tax_resident_rf_flag` boolean,

`type_code` string)

PARTITIONED BY (

`p1month` string)

ROW FORMAT SERDE

'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'

STORED AS INPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'

OUTPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat'

LOCATION

'hdfs://hdfsgw/arnsdpfess2__USL_TRADEFIN_NDL_UVDO_XS_SNP-USL_TRADEFIN_NDL_UVDO_XS_SNP-SUBJ_H/data/usl/tradefin_ndl_uvdo_xs/snp/subj_h'

TBLPROPERTIES (

'bucketing_version'='2',

'spark.sql.partitionProvider'='catalog',

'transient_lastDdlTime'='1765597417')

 

createtab_stmt

CREATE EXTERNAL TABLE `prx_usl_tradefin_ndl_uvdo_xs_snp_usl_tradefin_ndl_uvdo_xs_snp.agr`(

`agr_dp_code` string,

`agr_sk` bigint,

`close_dt` date,

`crpcr_cgc_prod_dp_code` string,

`crpcr_cgc_prod_sk` bigint,

`crpcr_creditor_subj_dp_code` string,

`crpcr_creditor_subj_sk` bigint,

`crpcr_debtor_subj_dp_code` string,

`crpcr_debtor_subj_sk` bigint,

`crpcr_first_give_dt` date,

`crpcr_line_agr_dp_code` string,

`crpcr_line_agr_sk` bigint,

`crpcr_line_limit_change_flag` boolean,

`crpcr_manual_sprt_flag` boolean,

`crpcr_one_annuity_flag` boolean,

`crpcr_sber_doc_dp_code` string,

`crpcr_sber_doc_sk` bigint,

`ctl_loading` bigint,

`ctl_validfrom` timestamp,

`deleted_flag` boolean,

`docum_tran_participation_role_dp_code` string,

`docum_tran_participation_role_sk` bigint,

`escrow_agr_amt` decimal(38,10),

`escrow_agr_depon_dt` date,

`escrow_crncy_dp_code` string,

`escrow_crncy_sk` bigint,

`escrow_disclosure_agr_dp_code` string,

`escrow_disclosure_agr_sk` bigint,

`escrow_docum_base_type_dp_code` string,

`escrow_docum_base_type_sk` bigint,

`escrow_object_commiss_dt` date,

`escrow_payer_cred_agr_dp_code` string,

`escrow_payer_cred_agr_sk` bigint,

`frame_letter_cred_org_agr_dp_code` string,

`frame_letter_cred_org_agr_sk` bigint,

`init_anlt_div_dp_code` string,

`init_anlt_div_sk` bigint,

`init_div_code` string,

`init_expire_dt` date,

`issuing_subj_dp_code` string,

`issuing_subj_sk` bigint,

`letter_cred_coverage_crdt_funds_first_amt` decimal(38,10),

`letter_cred_coverage_crncy_dp_code` string,

`letter_cred_coverage_crncy_sk` bigint,

`letter_cred_coverage_flag` boolean,

`letter_cred_coverage_own_funds_first_amt` decimal(38,10),

`letter_cred_org_financing_dt` date,

`letter_cred_source_coverage_type_dp_code` string,

`letter_cred_source_coverage_type_sk` bigint,

`letter_cred_type_dp_code` string,

`letter_cred_type_sk` bigint,

`num` string,

`open_dt` date,

`sid` string,

`sign_dt` date,

`type_code` string)

ROW FORMAT SERDE

'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'

STORED AS INPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'

OUTPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat'

LOCATION

'hdfs://hdfsgw/arnsdpfess2__USL_TRADEFIN_NDL_UVDO_XS_SNP-USL_TRADEFIN_NDL_UVDO_XS_SNP-AGR/data/usl/tradefin_ndl_uvdo_xs/snp/agr'

TBLPROPERTIES (

'bucketing_version'='2',

'spark.sql.statistics.numRows'='4139249',

'spark.sql.statistics.totalSize'='222920656',

'transient_lastDdlTime'='1765597611')

 

createtab_stmt

CREATE EXTERNAL TABLE `prx_usl_tradefin_ndl_uvdo_xs_snp_usl_tradefin_ndl_uvdo_xs_snp.agr_proc`(

`advising_subj_dp_code` string,

`advising_subj_sk` bigint,

`agr_dp_code` string,

`agr_sk` bigint,

`confirming_subj_dp_code` string,

`confirming_subj_sk` bigint,

`crpcr_corp_cgc_agr_status_dp_code` string,

`crpcr_corp_cgc_agr_status_sk` bigint,

`ctl_loading` bigint,

`ctl_validfrom` timestamp,

`docum_tran_seller_subj_dp_code` string,

`docum_tran_seller_subj_sk` bigint,

`end_dt` date,

`letter_cred_ind_buyer_subj_dp_code` string,

`letter_cred_ind_buyer_subj_sk` bigint,

`letter_cred_org_buyer_subj_dp_code` string,

`letter_cred_org_buyer_subj_sk` bigint,

`letter_cred_org_max_delay_bank_dt` date,

`letter_cred_org_max_delay_seller_dt` date,

`letter_cred_revocable_flag` boolean,

`nominated_subj_dp_code` string,

`nominated_subj_sk` bigint,

`reimbursing_subj_dp_code` string,

`reimbursing_subj_sk` bigint,

`srv_anlt_div_dp_code` string,

`srv_anlt_div_sk` bigint,

`srv_div_code` string,

`start_dt` date,

`type_code` string)

PARTITIONED BY (

`p1month` string)

ROW FORMAT SERDE

'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'

STORED AS INPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'

OUTPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat'

LOCATION

'hdfs://hdfsgw/arnsdpfess2__USL_TRADEFIN_NDL_UVDO_XS_SNP-USL_TRADEFIN_NDL_UVDO_XS_SNP-AGR_PROC/data/usl/tradefin_ndl_uvdo_xs/snp/agr_proc'

TBLPROPERTIES (

'bucketing_version'='2',

'spark.sql.partitionProvider'='catalog',

'transient_lastDdlTime'='1765598066')

createtab_stmt

CREATE EXTERNAL TABLE `prx_usl_tradefin_ndl_uvdo_xs_snp_usl_tradefin_ndl_uvdo_xs_snp.agr_fin`(

`agr_dp_code` string,

`agr_sk` bigint,

`crpcr_line_crncy_dp_code` string,

`crpcr_line_crncy_sk` bigint,

`crpcr_line_limit_amt` decimal(38,10),

`crpcr_one_amt` decimal(38,10),

`crpcr_one_crncy_dp_code` string,

`crpcr_one_crncy_sk` bigint,

`ctl_loading` bigint,

`ctl_validfrom` timestamp,

`docum_tran_amt` decimal(38,10),

`docum_tran_crncy_dp_code` string,

`docum_tran_crncy_sk` bigint,

`end_dt` date,

`frame_letter_cred_org_crncy_dp_code` string,

`frame_letter_cred_org_crncy_sk` bigint,

`frame_letter_cred_org_lim_amt` decimal(38,10),

`letter_cred_coverage_amt` decimal(38,10),

`start_dt` date,

`type_code` string)

PARTITIONED BY (

`p1month` string)

ROW FORMAT SERDE

'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'

STORED AS INPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'

OUTPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat'

LOCATION

'hdfs://hdfsgw/arnsdpfess2__USL_TRADEFIN_NDL_UVDO_XS_SNP-USL_TRADEFIN_NDL_UVDO_XS_SNP-AGR_FIN/data/usl/tradefin_ndl_uvdo_xs/snp/agr_fin'

TBLPROPERTIES (

'bucketing_version'='2',

'spark.sql.partitionProvider'='catalog',

'transient_lastDdlTime'='1765598020')

 

createtab_stmt

CREATE EXTERNAL TABLE `prx_usl_tradefin_ndl_uvdo_xs_snp_usl_tradefin_ndl_uvdo_xs_snp.letter_cred_org_plan_payment`(

`ctl_loading` bigint,

`ctl_validfrom` timestamp,

`deleted_flag` boolean,

`letter_cred_org_plan_payment_amt` decimal(38,10),

`letter_cred_org_plan_payment_crncy_dp_code` string,

`letter_cred_org_plan_payment_crncy_sk` bigint,

`letter_cred_org_plan_payment_delay_bank_dt` date,

`letter_cred_org_plan_payment_delay_seller_dt` date,

`letter_cred_org_plan_payment_dp_code` string,

`letter_cred_org_plan_payment_dt` date,

`letter_cred_org_plan_payment_sk` bigint,

`plan_payment_agr_dp_code` string,

`plan_payment_agr_sk` bigint,

`sid` string)

ROW FORMAT SERDE

'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'

STORED AS INPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'

OUTPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat'

LOCATION

'hdfs://hdfsgw/arnsdpfess2__USL_TRADEFIN_NDL_UVDO_XS_SNP-USL_TRADEFIN_NDL_UVDO_XS_SNP-LETTER_CRED_ORG_PLAN_PAYMENT/data/usl/tradefin_ndl_uvdo_xs/snp/letter_cred_org_plan_payment'

TBLPROPERTIES (

'bucketing_version'='2',

'spark.sql.statistics.numRows'='3960',

'spark.sql.statistics.totalSize'='126307',

'transient_lastDdlTime'='1765597953')

 

createtab_stmt

CREATE EXTERNAL TABLE `prx_usl_tradefin_ndl_uvdo_xs_snp_usl_tradefin_ndl_uvdo_xs_snp.letter_cred_type`(

`ctl_loading` bigint,

`ctl_validfrom` timestamp,

`deleted_flag` boolean,

`letter_cred_type_code` string,

`letter_cred_type_dp_code` string,

`letter_cred_type_name` string,

`letter_cred_type_sk` bigint,

`sid` string)

ROW FORMAT SERDE

'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe'

STORED AS INPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat'

OUTPUTFORMAT

'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat'

LOCATION

'hdfs://hdfsgw/arnsdpfess2__USL_TRADEFIN_NDL_UVDO_XS_SNP-USL_TRADEFIN_NDL_UVDO_XS_SNP-LETTER_CRED_TYPE/data/usl/tradefin_ndl_uvdo_xs/snp/letter_cred_type'

TBLPROPERTIES (

'bucketing_version'='2',

'spark.sql.statistics.numRows'='14',

'spark.sql.statistics.totalSize'='3246',

'transient_lastDdlTime'='1765596987')

 

 

